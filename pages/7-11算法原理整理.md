# Lecture 8

## 问题一：一个无向图，计算其生成树的数量

首先解释什么是生成树。

如果$G = (X,A)$ 是一个有n个端点的无向图，那么一个包含G中所有端点的部分图就称为一个生成树。

一个无向图可以有多个生成树。

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505162443372.png" alt="image-20220505162443372" style="zoom: 50%;" />

### 算法一：画图法

![image-20220505162601677](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505162601677.png)

### 算法二：矩阵法

## 问题二：计算最小生成树

### 算法一：The Kruskal algorithm

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505163217882.png" alt="image-20220505163217882" style="zoom: 25%;" />

第一步：列出图中所有端点（vertex）

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505163259755.png" alt="image-20220505163259755" style="zoom:33%;" />

第二步：根据权重，给每对端点排序。

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505163334067.png" alt="image-20220505163334067" style="zoom:25%;" />

第三步：按顺序将每对端点加入结果的生成树中，保证每增加的一对端点不会使生成树变成一个回路（说白了，新加入的端点不能两头都用过）

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505163557746.png" alt="image-20220505163557746" style="zoom:33%;" />

### 算法二：The algorithm of Prim

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505164144537.png" alt="image-20220505164144537" style="zoom:33%;" />

第一步：找到一个起始点，令$T_s = {x_s}, A_S = \empty$  

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505164216076.png" alt="image-20220505164216076" style="zoom: 50%;" />

第二步：以Ts中的端点为起始，列出所有它能到达的点，并写出对应支付

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505164312255.png" alt="image-20220505164312255" style="zoom:50%;" />

第三步：在以上几个端点中选择支付最小的一个，并将其添加进Ts中，将这对端点添加进As中

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505164501606.png" alt="image-20220505164501606" style="zoom:50%;" />

第四步：此时本例中已被选择的端点有a和b两个，重复第二和第三步。直到所有端点都被包含进了Ts。

![image-20220505164941716](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505164941716.png)

![image-20220505165006360](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505165006360.png)

# Lecture 9

## 问题三：最短路径问题

### 算法一：Dijkstra's  Algorithm $(c_{ij}\geq0)$

<img src="7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505172139416.png" alt="image-20220505172139416" style="zoom:50%;" />

本算法靠一个矩阵实现

第一步：初始化，点1为0，其余为$\infty$

![image-20220505172447047](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505172447047.png)

第二步：从点1出发能抵达的端点标上数字，并选其中支付最小的一个。

![image-20220505172539808](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505172539808.png)

第三步：以上一步所得端点为起点，更新初始点与各个短点的距离，若新距离小于原距离则替换，反之则不变、

![image-20220505173335588](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505173335588.png)

第四步：重复以上步骤。

![image-20220505173358305](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505173358305.png)

### 算法二：Bellman-Ford algorithm

![image-20220505173526498](7-11%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86.assets/image-20220505173526498.png)

与上个算法类似，本算法也是利用矩阵求解。但是有所不同的是，本算法可以计算支付为负数的情况。

首先从起点1出发，初始化 $S = \Gamma (1) = \{2,3\}$, 

计算点1到其他点的距离，并记录到矩阵中$l_1(1) = 0, l_1(2) = -1, l_1(3) = 5, l_1(4) = l_1(5) = \infty.$

|      |  1   |  2   |  3   |    4     |    5     |
| :--: | :--: | :--: | :--: | :------: | :------: |
|  1   |  0   |  -1  |  5   | $\infty$ | $\infty$ |
|  2   |  0   |  -1  |  -4  |    4     |    8     |
|  3   |  0   |  -1  |  -4  |    4     |    -1    |
|  4   |  0   |  -1  |  -4  |    2     |    -1    |
|  5   |  0   |  -1  |  -4  |    2     |    -1    |

找到$\Gamma(S) = \{2,3,4,5\}.$

3: $T_3 = \Gamma^{-1}(3) \cap S = \{2\}$

$l_2(3) = min\{l_1(2),l_1(2)+c(2,3)\} = min\{5,-1-3 \} = -4$ 

4: $T_4 = \Gamma^{-1}(4) \cap S = \{2\}$

$l_2(4) = min\{l_1(4),l_1(2)+c(2,4)\} = min\{\infty, 4 \} = 4$ 

5: $T_5 = \Gamma^{-1}(5) \cap S = \{3\}$

$l_2(5) = min\{l_1(5),l_1(3)+c(3,5)\} = min\{\infty,8 \} = 8$

 Form new S: $S = \{ x_i|l_{k+1}(x_i)\neq l_k(x_i)\} = \{3,4,5\}$

$\Gamma(S) = {2,4,5}$ 

2: $T_2 = \Gamma^{-1}(2) \cap S = \{3\}$

$l_3(2) = min\{l_2(2),l_2(3)+c(3,2)\} = min\{-1,-4+4 \} = -1$ 

4: $T_4 = \Gamma^{-1}(4) \cap S = \{5\}$

$l_3(4) = min\{l_2(4),l_2(5)+c(5,4)\} = min\{4,11 \} = 4$ 

5: $T_5 = \Gamma^{-1}(5) \cap S = \{3,4\}$

$l_3(5) = min\{l_2(5),l_2(3)+c(3,5),l_2(4)+c(4,5)\} = min\{8,-1,3 \} = -1$ 

Form new S: $S = \{ x_i|l_{k+1}(x_i)\neq l_k(x_i)\} = \{5\}$

$\Gamma(S) = {4}$ 

4: $T_4 = \Gamma^{-1}(4) \cap S = \{5\}$

$l_4(4) = min\{l_3(4),l_3(5)+c(5,4)\} = min\{4,2 \} = 2$ 

Form new S: $S = \{ x_i|l_{k+1}(x_i)\neq l_k(x_i)\} = \{4\}$

$\Gamma(S) = {5}$ 

5: $T_5 = \Gamma^{-1}(5) \cap S = \{4\}$

$l_5(5) = min\{l_3(5),l_3(4)+c(4,5)\} = min\{-1,1 \} = -1$ 

The lables as same as $l_4$ so stop.









# Lecture 11

